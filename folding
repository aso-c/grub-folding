#! /bin/sh
set -e
#***************************************************************************************#
#											#
# Insert Folding section in GRUB configuration file					#
# (c) aso, v.2.0.7 by 17.06.2014.							#
#   GPLv3										#
#											#
# -t, --pipline           processing input file (stdin) into stdout output file		#
# -i, --in-place          processing config file "in place" from stdout; default option	#
#											#
#***************************************************************************************#


ver='2.0.7'
version="v.$ver, by 17.06.2014 from aso"

gen='gen'
win='win'

sysconfdir="/etc"
#grub_mkcfg_dir="${sysconfdir}/grub.d"
# for dev
grub_mkcfg_dir='./my.grub.d'

self=`basename $0`
GRUB_PREFIX=`echo '/boot/grub' | sed "s,//*,/,g"`

tmpdir='/tmp'
tmprefix="$tmpdir/fold$$$"



BEG='BEGIN'
EN='END'


usage()
{
    cat <<EOF
Usage: $self [OPTION]
Insert Folding section in GRUB configuration file

  -t, --pipline           processing input file (stdin) into stdout output file
  -i, --in-place          processing config file "in place" from stdout; default option

###Report bugs to <bug-grub@gnu.org>.
EOF
} # usage() --------------------------------------


#
# Shielded Slash
# for using in sed-scripts
#shield()
shield0()
{
    echo $* | sed 's/\//\\&/'g
} # shldslash


#
# Shielding
# for using in sed-scripts
#
# TODO: Замена должна иметь вид:
# [' ', '(', ');, '|'] -> ['\ ', '\(', '\)', '\|'] ; возможно что-то ещё, например '\'
# &[' ', '(', ');, '|'] -> [' ', '(', ');, '|'] ; отменяет действие, сохраняет первоначальный вид 
# && -> & ; отменяет действие '&'
#shield1()
shield()
{
    # The order is important!
    # The List like '[|(+)?]' - same at all function code.
    echo $* | sed -e 's/\([^&]\|&&\)\([|(+ )?]\)/\1\\\2/g' |
	sed -e 's/\([|(+ )?]\)\([|(+ )?]\)/\1\\\2/g; s/^[|(+ )?]/\\&/g' |
	sed -e "s/\([^&]\)&\([|(+ )?]\)/\1\2/g" |
	sed -e "s/\([|(+ )?]\)&\([|(+ )?]\)/\1\2/g" |
	sed -e 's/&&/\&/g' #|	sed -e 's/\n/\\\\n/g'
} # shield


# #
# # Test for shielding space
# # for using in sed-scripts
# shield3()
# {
# #    echo "${*}" | sed 's/ /\\&/'g
#     echo "${*}" | sed 's/[ \/]/\\&/'g
# } # shld3


# Create marker
mark() {
	local MARK='###'
    #echo "$MARK\ $1\ $MARK"
#    echo $(shield3 "$MARK $1 $MARK")
    echo "$MARK $1 $MARK"
} # mark() ---------------------------------------




# Echoing OS name from class
# Parameter:
#   #1 - class OS (gentoo, win),
o_name()
{
case "$1" in
# 'win')	  echo 'Microsoft Windows'	# product variant
'win')	  echo 'Windows'	# for test in laptop
	;;
'gentoo') echo 'Gentoo Linux'
	;;
'gen')	  echo 'Gentoo Linux'
	;;
esac
} # o_name() -------------------------------------


# Create full format marker string
# Paramatars:
#   $1 - 'BEGIN' / 'END'
#   $2 - full file name
fullmark()
{
#    shield0 $(mark "$1\ $grub_mkcfg_dir/$2")
#    shield0 $(shield3 $(mark "$1 $grub_mkcfg_dir/$2"))
#    shield3 $(mark "$1 $grub_mkcfg_dir/$2")
    shield $(mark "$1 $grub_mkcfg_dir/$2")
#    mark "$1 $grub_mkcfg_dir/$2"
} # fullmark() -----------------------------------



p='prolog'
e='epilog'

# Echoing string of control comment
# Parameters:
#   $1 - OS class (gen, win...)
#   $2 - tail (prolog, epilog...)
echo_cmd()
{
    echo "$(fullmark $BEG _$1-$2)\\"
#    shield3 $(mark "$BEG $grub_mkcfg_dir/_$1-$2")
#    echo "$(shield3 "$(mark "$BEG $grub_mkcfg_dir/_$1-$2")")"
    echo "# exec!$grub_mkcfg_dir/_$1-$2 -i #\\"
#    echo "$(fullmark $EN _$1-$2)\\n"
#    shield3 $(mark "$EN $grub_mkcfg_dir/_$1-$2")\\n
    shield $(mark "$EN $grub_mkcfg_dir/_$1-$2")\\n
} # echo_cmd


# Echoing string for markup section in config file function
# Parameters:
#   $1 - OS class (gen, win...)
echo_remark()
{
	# regexp block for using in criteria for sampling full menu srction
	local blkcmt='([^{#}\\n]*(#[^\\n]*)?\\n)*[^{#}\\n]*'

cat << EOF
## entrance
# # if not matched submenu - go to presample
#  /\([^#]*.*submenu\)/! b presample; $ b
#  # resampling of inner sequence
#  b #exit
  
#presample
  # if not matched /menuentry <OS_Name>/ - e.g. needed section was not started - exit
#  /\([^#]*menuentry\)\([^#]\+$(o_name $1)\)/! b; $ b
  /^[ \t]*menuentry[^#]\+$(o_name $1)/! b; $ b

:presample
  # presampling menuentry section & intersection gap into pattern space
  /^$(shield "$blkcmt{($blkcmt{($blkcmt{$blkcmt})*$blkcmt})*$blkcmt}")/! { N; b presample}

  N; /### \($BEG\)\|\($EN\)/ b		# control comment - go out
  /\n[^#\n]*menuentry/! b presample	# detect that not start of new section - continue
  /\n[^#\n]*$(o_name $1)/! b		# new section is not in sequence - go out

  # insert control comment before output buffer
  i\\\\
  i\\$(echo_cmd $1 $p)
#  i\\\\n\\$(echo_cmd $1 $p)
 
:consect	# continue sampling section
#  n; /^}/! b consect

:intersect	# out of section, sampling interval between sections
  n
:blank
#   /[^\n]\+/ b substance		# if current line is not blank
#     N; b blank
  /[^\n]\+/! {N; b blank}		# if current line is blank - continue sampling

:substance
  /### \($BEG\)\|\($EN\)/ b close	# control comment - close section
  /[^#]*menuentry/! b intersect		# detect that not start of new section
  /[^#]*$(o_name $1)/ b consect		# new section is started

:close
  i\\$(echo_cmd $1 $e)
  /### BEG/! i\\\\
EOF
} # echo_remark() -------------------------------------------------------------------------


# Insert folding section in config file function on file insertion
# Parameters:
#   $1 - OS class (win/gentoo)
#   $2 - sect class (prolog/epilog)
remark_insert()
{
#    sed -e "s/# *exec! *\($(shield0 ${grub_mkcfg_dir}/_$1-$2)\)\([^#]*\)/\1\2 /e"
#    sed -e "s/# *exec! *\($(shield3 ${grub_mkcfg_dir}/_$1-$2)\)\([^#]*\)/\1\2 /e"
#    sed -e "s/# *exec! *\($(shield ${grub_mkcfg_dir}/_$1-$2)\)\([^#]*\)/\1\2 /e"
#    sed -e "s/# *exec! *\(${grub_mkcfg_dir}/_$1-$2\)\([^#]*\)/\1\2 /e"
#    sed -e "s/# *exec! $(shield "*($(shield0 ${grub_mkcfg_dir}/_$1-$2))([^#]*)")/\1\2 /e"
    sed -e "s/# *exec! $(shield $(shield0 "*(${grub_mkcfg_dir}/_$1-$2)([^#]*)"))/\1\2 /e"
} # remark_insert()------------------------------------------------------------


#for dev target
if [ $_dev ] ; then
    return
fi


# Processing the arguments.
while test $# -gt 0
do
    option=$1
    shift

    case "$option" in
    -h | --help)
	usage
	exit 2 ;;
    -v | --version)
#	echo "$self (${PACKAGE_NAME}) ${PACKAGE_VERSION}"
	echo $version
	exit 0 ;;
    -t | --pipeline)
	pipe=${option} ;;
    -i | --in-place)
	pipe='' ;;
    -*)
	allopts="$allopts $option"
	;;
    # Explicitly ignore non-option arguments, for compatibility.
    esac
done


echo "Folding (v.$ver) ..." >&2

echo "# Folding $version"
echo "# This is a stub"
echo "# Output of this module was placed bypass the main flow"


if ! [ $pipe ] ; then

  tmpbuf='/tmp/$$$sect$$$'
  exec 4<&0	# store stdin into #4
  exec 6>&1	# store stdout into #6
  outfile=$(readlink /proc/self/fd/6)
  set -- $(du -b $outfile); fsz1=$1
  exec 1>&-		# close stdout
  exec 0< $outfile
  exec 1> $tmpbuf

fi


##************##



sed $allopts -e "$(echo_remark $win)"	|
sed $allopts -e "$(echo_remark $gen)"	|
remark_insert $win $p	|
remark_insert $win $e	|
remark_insert $gen $p	|
remark_insert $gen $e

##************##


if ! [ $pipe ] ; then
	#restore all files
  exec 1>&-		# close stdout
  exec 0<&-		# close stdin
  set -- $(du -b $tmpbuf); fsz2=$1
  cat $tmpbuf > $outfile
  exec 0<&4
  exec 1>&6
  tail -c $(($fsz2 - $fsz1)) $tmpbuf
  rm "$tmpbuf"	# remove tmpbuf

fi
