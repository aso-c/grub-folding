#! /bin/sh
set -e

#
# grub-mkconfig helper script.
# (c) aso<Solomatov.A.A@gmail.com>, v.2.2.3 by 11.07.2014.							#
#   GPLv3
#
# -t, --pipeline,     pipline mode: data from input file (stdin) processed 'on fly'
#     --pipe              and saved into stdout output file (intended for debug)
# -i, --in-place      processing config file "in place" from stdout; default option
#
# This config script create separate submenu for each group of consequtive items
# GRUB boot menu for each type OS.
# It will be processed to the next operating systems:
# - Microsoft Windows;
# - Gentoo.
#
# Project files:
#    - folding - the config script that creates a submenu from sequence of a homogeneous
#                  menu items.
#    - _gen-prolog  - Gentoo section prologue file; it can contain custom code,
# 		      that will be placed immediately before the submenu "Gentoo"
#		      or inside submenu at the beginning of it.
#		      Submenu title also given in that file.
#    - _gen-epilog  - Gentoo section epilogue file; it can contain custom code,
#		      that will be placed immediately after the submenu "Gentoo"
#		      or inside submenu at the end of it.
#    - _win-prolog  - Microsoft Windows section prologue file; it can contain custom code,
#		      that will be placed immediately before the submenu "Microsoft Windows"
#		      or inside submenu at the beginning of it.
#		      Submenu title also given in that file.
#    - _win-epilog  - Microsoft Windows section epilogue file; it can contain custom code,
#		      that will be placed immediately after the submenu "Microsoft Windows"
#		      or inside submenu at the end of it.
#		      Submenu title also given in that file.
#
# The project files are placed in /etc/grub.d directory.
# The "folding" script in the order of execution must follow after os_prober and before
# user scripts (usually exec priority 40 and more), e.g. 31..39. (39_folding, for example).
# Section files priority is absent, they used in its original form.
#

ver='2.2.3'
version="v.$ver, by 11.07.2014 from aso"

gen='gen'
win='win'

sysconfdir="/etc"
#grub_mkcfg_dir="${sysconfdir}/grub.d"
# for dev
grub_mkcfg_dir='./my.grub.d'

self=`basename $0`
GRUB_PREFIX=`echo '/boot/grub' | sed "s,//*,/,g"`

tmpdir='/tmp'
tmprefix="$tmpdir/fold$$$"





usage()
{
    cat <<EOF
Usage: $self [OPTION]
Insert Folding section in GRUB configuration file

  -h, --help             this help
  -v, --version          version of the program
  -t, --pipeline, --pipe processing input file (stdin) into stdout output file
  -i, --in-place         processing config file "in place" from stdout; default option

Report bugs to <Solomatov.A.A@gmail.com>.

$version
EOF
} # usage() --------------------------------------


#
# Shielding with parameter analyses
# for using in sed-scripts
# Simplified sintax:
#	any symbols from set: {| (+ )?} -> \{original_symbol}
#	single symbol \ w/o {| (+ )?}   -> \\{original_symbol}
#	char chain \{| (+ )?}           -> {original_symbol} (w/o '\')
#       char chain \\                   -> \
# TODO: Замена должна иметь вид:
# [' ', '(', ');, '|'] -> ['\ ', '\(', '\)', '\|'] ; возможно что-то ещё, например '\'
# &[' ', '(', ');, '|'] -> [' ', '(', ');, '|'] ; отменяет действие, сохраняет первоначальный вид 
# && -> & ; отменяет действие '&'
# -i, --slash-screening - экранирование символа косой '/' (по умолчанию - нет)
# -b, --space-ignore - не экранировать пробелы
# -n, --no-std-subst - не делать стандартную подстановку
shield2()
#shield()
{
# 	local subst='| (+)?'

	    local subst_base='|(+)?'
#	    local subst=" ${subst_base}"
	    local subst='|(+ )?'

    # parameter - substitution string
    main_subst()
    {
	# The order is important!
	sed -e "s/[${1}]/\\\&/g;" -e "s/\(\\\\\\\\\)\([${1}]\)/\2/g"
    } # main_subst()

    cfg=''
    # Processing the arguments.
    while getopts bin f
    do
	case $f in
	b)
	    # не экранировать пробелы
	    cfg="b$cfg"
	    ;;
	i)
	    # экранировать косую ('/')
	    cfg="i$cfg"
	    ;;
	n)
	    # отменить стандартные подстановки
	    cfg="n$cfg"
	    ;;
# 	--)
#  	    break ;;
#  	# Explicitly ignore unexpected options, for compatibility.
#  	-*)
#  	    #allopts="$allopts $option"
#  	    ;;
	esac
    done
#    shift `expr $OPTIND - 1`
    shift $(expr $OPTIND - 1)

    if [ "$(expr index ${cfg}u n)" != 0 ] ; then
	# echo 'Stdandard subst canceled'
	subst="$(echo "${subst}" | sed -e 's/[|(+)?]//g')"
    fi

   if [ "$(expr index u$cfg b)" != 0 ] ; then
	# echo 'Space screening is cancelled'
	subst="$(echo "${subst}" | sed -e 's/ //g')"
    fi

    if [ "$(expr index u$cfg i)" != 0 ] ; then
	# echo "Screening the slash - '/'"
	subst="/$subst"
    fi

    if [ "$1no" = 'no' ] ; then
	# use in pipe-mode
	main_subst "${subst}"
     else
	# use parameter as input
	echo "${*}" | main_subst "${subst}"
    fi
} # shield2


#
# Shielding with parameter analyses
# for using in sed-scripts
# Simplified sintax:
#	any symbols from set: {| (+ )?} -> \{original_symbol}
#	single symbol \ w/o {| (+ )?}   -> \\{original_symbol}
#	char chain \{| (+ )?}           -> {original_symbol} (w/o '\')
#       char chain \\                   -> \
# TODO: Замена должна иметь вид:
# [' ', '(', ');, '|'] -> ['\ ', '\(', '\)', '\|'] ; возможно что-то ещё, например '\'
# &[' ', '(', ');, '|'] -> [' ', '(', ');, '|'] ; отменяет действие, сохраняет первоначальный вид 
# && -> & ; отменяет действие '&'
# -i, --slash-screening - экранирование символа косой '/' (по умолчанию - нет)
# -b, --space-ignore - не экранировать пробелы
# -n, --no-std-subst - не делать стандартную подстановку
#shield1()
shield()
{
# 	local subst='| (+)?'

	    local subst_base='|(+)?'
#	    local subst=" ${subst_base}"
	    local subst='|(+ )?'

    # parameter - substitution string
    main_subst()
    {
# 	    local subst_base='|(+)?'
# 	    local subst="$(subst_base) "

	# The order is important!
	# The List like '[|(+)?]' - same at all function code.
	#sed -e 's/[|(+ )?]/\\&/g'
	#sed -e "s/[|(+ )?]/\\\&/g"
	#sed -e "s/[${subst}]/\\\&/g"
	sed -e "s/[${1}]/\\\&/g;" -e "s/\(\\\\\\\\\)\([${1}]\)/\2/g"
	# -e 's/\\\\/\&/g'
	# -e 's/\(\\\\\)\([${1}]\)/\2/g'
	# -e "s/\\\+[^${1}]/\\\&/g"
#	echo "s/[${subst}]/\\\&/g"
    } # main_subst()

    echo "shield last v.1 options in: ${@}" >&2
    echo '\n' >&2


    # Processing the arguments.
    while getopts ibn f
    do
	case $f in
	b)
	    # не экранировать пробелы
	    echo '--=** No space screening **=--' >&2
	    subst="$(echo "${subst}" | sed -e 's/ //g')" ;;
	i)
	    # экранировать косую ('/')
	    echo "--=** Screening the slash - '/' **=--" >&2
	    subst="/$subst" ;;
	n)
	    # отменить стандартные подстановки
	    echo '--=** Std subst is canceled **=--' >&2
	    subst="$(echo "${subst}" | sed -e 's/[|(+)?]//g')" ;;
	esac
    done
    shift $(($OPTIND - 1))

    echo "\noptions out: ${@}\n" >&2
#    echo "cfg is: $cfg" >&2

    echo "subst is [${subst}]" >&2

	ex=''
#    ex="main_subst \"${subst}\""
    if [ "$1no" != 'no' ] ; then
	echo '####!!! send parameter to pipe' >&2
	ex='echo ${@} | '
#	ex="echo \"${*}\" | $ex"
    fi

#    $ex main_subst "${subst}"
    eval "${ex} main_subst \"${subst}\""

	#sed -e "s/[|(+ )?]/\\\&/g"
	#sed -e "s/[${subst}]/\\\&/g"
#	$ex sed -e "s/[${1}]/\\\&/g;" -e "s/\(\\\\\\\\\)\([${1}]\)/\2/g"
	# -e 's/\\\\/\&/g'
	# -e 's/\(\\\\\)\([${1}]\)/\2/g'

} # shield


# Create marker
mark() {
    echo "### $1 ###"
} # mark() ---------------------------------------


# Echoing OS name from class
# Parameter:
#   #1 - class OS (gentoo, win),
o_name()
{
case "$1" in
# 'win')	  echo 'Microsoft Windows'	# product variant
'win')	  echo 'Windows'	# for test in laptop
	;;
'gentoo') echo 'Gentoo Linux'
	;;
'gen')	  echo 'Gentoo Linux'
	;;
esac
} # o_name() -------------------------------------


p='prolog'
e='epilog'

BEG='BEGIN'
EN='END'

# Echoing string of control comment
# Parameters:
#   $1 - OS class (gen, win...)
#   $2 - tail (prolog, epilog...)
echo_cmd()
{
    shield $(mark "$BEG $grub_mkcfg_dir/_$1-$2")\\
    echo "# exec!$grub_mkcfg_dir/_$1-$2 -i #\\"
    shield $(mark "$EN $grub_mkcfg_dir/_$1-$2")\\n
} # echo_cmd


# Echoing string for markup section in config file function
# Parameters:
#   $1 - OS class (gen, win...)
echo_remark()
{
	# regexp block for using in criteria for sampling full menu srction
	local blkcmt='([^{#}\\n]*(#[^\\n]*)?\\n)*[^{#}\\n]*'

cat << EOF
## entrance
# # if not matched submenu - go to presample
#  /\([^#]*.*submenu\)/! b presample; $ b
#  # resampling of inner sequence
#  b #exit
  
#presample
  # if not matched /menuentry <OS_Name>/ - e.g. needed section was not started - exit
#  /\([^#]*menuentry\)\([^#]\+$(o_name $1)\)/! b; $ b
  /^[ \t]*menuentry[^#]\+$(o_name $1)/! b; $ b

:presample
  # presampling menuentry section & intersection gap into pattern space
  /^$(shield "$blkcmt{($blkcmt{($blkcmt{$blkcmt})*$blkcmt})*$blkcmt}")/! { N; b presample}

  N; /### \($BEG\)\|\($EN\)/ b		# control comment - go out
  /\n[^#\n]*submenu/ b			# other submenu section was started
  /\n[^#\n]*menuentry/! b presample	# detect that not start of new section - continue
  /\n[^#\n]*$(o_name $1)/! b		# new section is not in sequence - go out

  # insert control comment before output buffer
  i\\\\
  i\\$(echo_cmd $1 $p)
#  i\\\\n\\$(echo_cmd $1 $p)
 
:consect; n	# continue sampling section

:blank
  /[^\n]\+/! {N; b blank}		# if current line is blank - continue sampling

  /### \($BEG\)\|\($EN\)/ b close	# control comment - close section
  /[^#]*submenu/ b close		# other subsection started
  /[^#]*menuentry/! b consect		# detect that not start of new section
  /[^#]*$(o_name $1)/ b consect		# new section is started

:close
  i\\$(echo_cmd $1 $e)
  /### BEG/! i\\\\
EOF
} # echo_remark() -------------------------------------------------------------------------


# Insert folding section in config file function on file insertion
# Parameters:
#   $1 - OS class (win/gen\gentoo\)
#   $2 - sect class (prolog/epilog)
remark_insert()
{
#    sed -e "s/# *exec! *\($(shield0 ${grub_mkcfg_dir}/_$1-$2)\)\([^#]*\)/\1\2 /e"
#    sed -e "s/# *exec! *\($(shield3 ${grub_mkcfg_dir}/_$1-$2)\)\([^#]*\)/\1\2 /e"
#    sed -e "s/# *exec! *\($(shield ${grub_mkcfg_dir}/_$1-$2)\)\([^#]*\)/\1\2 /e"
#    sed -e "s/# *exec! *\(${grub_mkcfg_dir}/_$1-$2\)\([^#]*\)/\1\2 /e"
#    sed -e "s/# *exec! $(shield "*($(shield0 ${grub_mkcfg_dir}/_$1-$2))([^#]*)")/\1\2 /e"
#    sed -e "s/# *exec! $(shield $(shield0 "*(${grub_mkcfg_dir}/_$1-$2)([^#]*)"))/\1\2 /e"
    sed -e "s/# *exec! $(shield -i "*(${grub_mkcfg_dir}/_$1-$2)([^#]*)")/\1\2 /e"
} # remark_insert()------------------------------------------------------------


# Insert folding section in config file function on file insertion
# Parameters:
#   $1 - OS class (win/gen\gentoo\)
#   $2 - sect class (prolog/epilog)
echo_final()
{
    echo "s/# *exec! $(shield -i "*(${grub_mkcfg_dir}/_$1-$2)([^#]*)")/\\\1\\\2 /e"
} # echo_final()---------------------------------------------------------------



#for dev target
if [ $_dev ] ; then
    return
fi


# Processing the arguments.

#---------------------------------------------------
# Note that we use `"$@"' to let each command-line parameter expand to a
# separate word. The quotes around `$@' are essential!
# We need TEMP as the `eval set --' would nuke the return value of getopt.
#TEMP=`getopt -o ab:c:: --long a-long,b-long:,c-long:: \
#     -n 'example.bash' -- "$@"`
#TEMP=`getopt -o hvti --long help,version,pipeline,in-place \
#     -s sh -n 'folding' -- "$@"`
TEMP=$(getopt -o hvti --long help,version,pipeline,in-place \
     -s sh -n 'folding' -- "$@")

#echo "options is: $@"
#echo "TEMP is $TEMP"

if [ $? != 0 ] ; then echo "Terminating..." >&2 ; exit 1 ; fi
# Note the quotes around `$TEMP': they are essential!
eval set -- "$TEMP"

echo "options 2 is: $@" >&2

while true ; do
#    echo "current option is: $1"
    case "$1" in

    -h|--help)
	usage
	exit 2 ;;
    -v|--version)
#	echo "$self (${PACKAGE_NAME}) ${PACKAGE_VERSION}"
	echo $version
	exit 0 ;;
    -t|--pipeline)
	pipe=${1} ;;
    -i|--in-place)
	pipe='' ;;
    --)
        shift
	break ;;
    -*)
	allopts="$allopts ${1}" ;;
    # Explicitly ignore non-option arguments, for compatibility.
    *)
	echo "Internal error!"
	exit 1 ;;

    esac
    shift
done


echo "Folding (v.$ver) ..." >&2

echo "# Folding $version"
echo "# This is a stub"
echo "# Output of this module was placed bypass the main flow"


if ! [ $pipe ] ; then

  tmpbuf='/tmp/$$$sect$$$'
  exec 4<&0	# store stdin into #4
  exec 6>&1	# store stdout into #6
  outfile=$(readlink /proc/self/fd/6)
  set -- $(du -b $outfile); fsz1=$1
  exec 1>&-		# close stdout
  exec 0< $outfile
  exec 1> $tmpbuf

fi


##************##


sed $allopts -e "$(echo_remark win)"	|
sed $allopts -e "$(echo_remark gen)"	|
sed $allopts -e "$(echo_final win $p)" |
sed $allopts -e "$(echo_final win $e)" |
sed $allopts -e "$(echo_final gen $p)" |
sed $allopts -e "$(echo_final gen $e)"

##************##


if ! [ $pipe ] ; then
	#restore all files
  exec 1>&-		# close stdout
  exec 0<&-		# close stdin
  set -- $(du -b $tmpbuf); fsz2=$1
  cat $tmpbuf > $outfile
  exec 0<&4
  exec 1>&6
  tail -c $(($fsz2 - $fsz1)) $tmpbuf
  rm "$tmpbuf"	# remove tmpbuf

fi
